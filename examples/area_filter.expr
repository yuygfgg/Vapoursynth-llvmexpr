# Copyright (C) 2025 yuygfgg
# 
# This file is part of Vapoursynth-llvmexpr.
# 
# Vapoursynth-llvmexpr is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Vapoursynth-llvmexpr is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Vapoursynth-llvmexpr.  If not, see <https://www.gnu.org/licenses/>.

@ifndef __SINGLEEXPR__
@error This expr should be used in SingleExpr mode
@endif

@if __OUTPUT_BITDEPTH__ == 32
@define FG_VAL 1
@else
@define FG_VAL 2 ** (__OUTPUT_BITDEPTH__ - 1)
@endif

@define BG_VAL 0
@define MIN_SIZE_THR 100

@define NUM_PIXELS __WIDTH__ * __HEIGHT__

@define MAX_LABELS (NUM_PIXELS) / 2 + 2

label_map = new(NUM_PIXELS);
parent = new(MAX_LABELS);
area = new(MAX_LABELS);

dx = new(4); # Delta X
dy = new(4); # Delta Y
dx[0] = -1; dy[0] =  0;
dx[1] = -1; dy[1] = -1;
dx[2] =  0; dy[2] = -1;
dx[3] =  1; dy[3] = -1;

# Initialize
i = 0;
while (i < MAX_LABELS) {
    parent[i] = i;
    area[i] = 0;
    i = i + 1;
}
i = 0;
while (i < NUM_PIXELS) {
    label_map[i] = 0;
    i = i + 1;
}

<global<parent>>
function find_root(Value i) {
    root = i;
    while (parent[root] != root) {
        root = parent[root];
    }
    while (parent[i] != root) {
        next_i = parent[i];
        parent[i] = root;
        i = next_i;
    }
    return root;
}

<global<parent>>
function union_sets(Value i, Value j) {
    i_root = find_root(i);
    j_root = find_root(j);
    if (i_root != j_root) {
        if (i_root < j_root) {
            parent[j_root] = i_root;
        } else {
            parent[i_root] = j_root;
        }
    }
}

# Labeling and Recording Equivalences
next_label = 1;
y = 0;
while (y < __HEIGHT__) {
    x = 0;
    while (x < __WIDTH__) {
        pixel_val = dyn($x, x, y, 0);

        if (pixel_val != BG_VAL) {
            neighbor_labels = new(4);
            n_count = 0;
            
            k = 0;
            while (k < 4) {
                nx = x + dx[k];
                ny = y + dy[k];

                # Boundary check (ny is always <= y, so only need ny >= 0)
                if (nx >= 0 && nx < __WIDTH__ && ny >= 0) {
                    if (dyn($x, nx, ny, 0) != BG_VAL) {
                        neighbor_labels[n_count] = label_map[ny * __WIDTH__ + nx];
                        n_count = n_count + 1;
                    }
                }
                k = k + 1;
            }

            if (n_count == 0) {
                label_map[y * __WIDTH__ + x] = next_label;
                next_label = next_label + 1;
            } else {
                current_label = neighbor_labels[0];
                k = 1;
                while(k < n_count) {
                    current_label = min(current_label, neighbor_labels[k]);
                    k = k + 1;
                }
                
                label_map[y * __WIDTH__ + x] = current_label;
                
                k = 0;
                while(k < n_count) {
                    union_sets(current_label, neighbor_labels[k]);
                    k = k + 1;
                }
            }
        }
        x = x + 1;
    }
    y = y + 1;
}

# Resolve Labels and Calculate Area
y = 0;
while (y < __HEIGHT__) {
    x = 0;
    while (x < __WIDTH__) {
        idx = y * __WIDTH__ + x;
        if (label_map[idx] > 0) {
            root = find_root(label_map[idx]);
            label_map[idx] = root;
            area[root] = area[root] + 1;
        }
        x = x + 1;
    }
    y = y + 1;
}

# Generate Final Output
y = 0;
while (y < __HEIGHT__) {
    x = 0;
    while (x < __WIDTH__) {
        final_val = BG_VAL;
        label = label_map[y * __WIDTH__ + x];
        if (label > 0) {
            if (area[label] >= MIN_SIZE_THR) {
                final_val = FG_VAL;
            }
        }
        store(x, y, 0, final_val);
        x = x + 1;
    }
    y = y + 1;
}