# Copyright (C) 2025 yuygfgg
# 
# This file is part of Vapoursynth-llvmexpr.
# 
# Vapoursynth-llvmexpr is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Vapoursynth-llvmexpr is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Vapoursynth-llvmexpr.  If not, see <https://www.gnu.org/licenses/>.

@ifndef __EXPR__
@error This expr should be used in Expr mode
@endif

@if __INPUT_NUM__ != 1
@error This expr requires exactly one input clip
@endif

@requires meta

# `a` parameter of knlmeanscl
@ifndef PATCH_RADIUS
@define PATCH_RADIUS 3
@endif
# `s` parameter of knlmeanscl
@ifndef SEARCH_RADIUS
@define SEARCH_RADIUS 4
@endif
# `h` parameter of knlmeanscl
@ifndef FILTER_STRENGTH
@define FILTER_STRENGTH 1.2
@endif
# `wmode` parameter of knlmeanscl
@ifndef WEIGHT_MODE
@define WEIGHT_MODE 0
@endif

_ = ASSERT_CONST(PATCH_RADIUS > 0, patch_radius, _must_be_positive)
_ = ASSERT_CONST(SEARCH_RADIUS > 0, search_radius, _must_be_positive)
_ = ASSERT_CONST(FILTER_STRENGTH > 0, filter_strength, _must_be_positive)
_ = ASSERT_CONST(WEIGHT_MODE >= 0 && WEIGHT_MODE <= 3, weight_mode, _must_be_0_1_2_or_3)

@define H_SQUARED (FILTER_STRENGTH * FILTER_STRENGTH)

@define PATCH_DIAMETER (2 * PATCH_RADIUS + 1)
@define PATCH_SIZE (PATCH_DIAMETER * PATCH_DIAMETER)

@define _GET_PX(i) ((i) % PATCH_DIAMETER - PATCH_RADIUS)
@define _GET_PY(i) ((i) / PATCH_DIAMETER - PATCH_RADIUS)

@define _GET_SQ_DIFF(i) ((dyn($x, cx1 + _GET_PX(i), cy1 + _GET_PY(i)) - dyn($x, cx2 + _GET_PX(i), cy2 + _GET_PY(i))) ** 2)

function patch_distance(cx1, cy1, cx2, cy2) {
    return JOIN(PATCH_SIZE, _GET_SQ_DIFF, +)
}

@define SEARCH_DIAMETER (2 * SEARCH_RADIUS + 1)
@define SEARCH_AREA (SEARCH_DIAMETER * SEARCH_DIAMETER)

@define _GET_SX(i) ($X + (i) % SEARCH_DIAMETER - SEARCH_RADIUS)
@define _GET_SY(i) ($Y + (i) / SEARCH_DIAMETER - SEARCH_RADIUS)

@if WEIGHT_MODE == 0
@define CALCULATE_WEIGHT(dist) (exp(-(dist) / H_SQUARED))
@else
@if WEIGHT_MODE == 1
@define CALCULATE_WEIGHT(dist) (max(0.0, 1.0 - (dist) / H_SQUARED))
@else
@if WEIGHT_MODE == 2
@define CALCULATE_WEIGHT(dist) ((max(0.0, 1.0 - (dist) / H_SQUARED)) * (max(0.0, 1.0 - (dist) / H_SQUARED)))
@else
@if WEIGHT_MODE == 3
@define _BASE_WEIGHT(dist) (max(0.0, 1.0 - (dist) / H_SQUARED))
@define _WEIGHT2(dist) (_BASE_WEIGHT(dist) * _BASE_WEIGHT(dist))
@define _WEIGHT4(dist) (_WEIGHT2(dist) * _WEIGHT2(dist))
@define CALCULATE_WEIGHT(dist) (_WEIGHT4(dist) * _WEIGHT4(dist))
@endif
@endif
@endif
@endif

@define _MAIN_LOOP_BODY(i) sx = _GET_SX(i); sy = _GET_SY(i); distance = patch_distance($X, $Y, sx, sy); weight = CALCULATE_WEIGHT(distance); search_pixel_value = dyn($x, sx, sy); total_weight = total_weight + weight; weighted_sum = weighted_sum + (search_pixel_value * weight);

weighted_sum = 0.0
total_weight = 0.0

UNROLL(SEARCH_AREA, _MAIN_LOOP_BODY)

RESULT = total_weight > 0 ? weighted_sum / total_weight : $x
