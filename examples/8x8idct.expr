# Copyright (C) 2025 yuygfgg
# 
# This file is part of Vapoursynth-llvmexpr.
# 
# Vapoursynth-llvmexpr is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Vapoursynth-llvmexpr is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Vapoursynth-llvmexpr.  If not, see <https://www.gnu.org/licenses/>.


# Inverse 8x8 Discrete Cosine Transform (IDCT)
#
# This script reconstructs pixel values from 8x8 blocks of DCT coefficients
# provided by the input source clip ($src0). The output at coordinate (X, Y)
# is the reconstructed pixel value (x, y) for the corresponding block.

@ifndef __EXPR__
@error This expr should be used in Expr mode
@endif

# ==============================================================================
# 1. SETUP: Determine current block and spatial coordinates (x, y)
# ==============================================================================

# DCT block size
N = 8

# Spatial coordinates (x, y) for the current output pixel within an 8x8 block.
x = $X % N
y = $Y % N

# Top-left corner of the current 8x8 source block of DCT coefficients.
block_x = trunc($X / N) * N
block_y = trunc($Y / N) * N


# ==============================================================================
# 2. DATA GATHERING: Load all 64 DCT coefficients from the source 8x8 block.
#    `g_uv` corresponds to the coefficient at frequency (u, v).
# ==============================================================================

g_00 = dyn($src0, block_x + 0, block_y + 0)
g_10 = dyn($src0, block_x + 1, block_y + 0)
g_20 = dyn($src0, block_x + 2, block_y + 0)
g_30 = dyn($src0, block_x + 3, block_y + 0)
g_40 = dyn($src0, block_x + 4, block_y + 0)
g_50 = dyn($src0, block_x + 5, block_y + 0)
g_60 = dyn($src0, block_x + 6, block_y + 0)
g_70 = dyn($src0, block_x + 7, block_y + 0)

g_01 = dyn($src0, block_x + 0, block_y + 1)
g_11 = dyn($src0, block_x + 1, block_y + 1)
g_21 = dyn($src0, block_x + 2, block_y + 1)
g_31 = dyn($src0, block_x + 3, block_y + 1)
g_41 = dyn($src0, block_x + 4, block_y + 1)
g_51 = dyn($src0, block_x + 5, block_y + 1)
g_61 = dyn($src0, block_x + 6, block_y + 1)
g_71 = dyn($src0, block_x + 7, block_y + 1)

g_02 = dyn($src0, block_x + 0, block_y + 2)
g_12 = dyn($src0, block_x + 1, block_y + 2)
g_22 = dyn($src0, block_x + 2, block_y + 2)
g_32 = dyn($src0, block_x + 3, block_y + 2)
g_42 = dyn($src0, block_x + 4, block_y + 2)
g_52 = dyn($src0, block_x + 5, block_y + 2)
g_62 = dyn($src0, block_x + 6, block_y + 2)
g_72 = dyn($src0, block_x + 7, block_y + 2)

g_03 = dyn($src0, block_x + 0, block_y + 3)
g_13 = dyn($src0, block_x + 1, block_y + 3)
g_23 = dyn($src0, block_x + 2, block_y + 3)
g_33 = dyn($src0, block_x + 3, block_y + 3)
g_43 = dyn($src0, block_x + 4, block_y + 3)
g_53 = dyn($src0, block_x + 5, block_y + 3)
g_63 = dyn($src0, block_x + 6, block_y + 3)
g_73 = dyn($src0, block_x + 7, block_y + 3)

g_04 = dyn($src0, block_x + 0, block_y + 4)
g_14 = dyn($src0, block_x + 1, block_y + 4)
g_24 = dyn($src0, block_x + 2, block_y + 4)
g_34 = dyn($src0, block_x + 3, block_y + 4)
g_44 = dyn($src0, block_x + 4, block_y + 4)
g_54 = dyn($src0, block_x + 5, block_y + 4)
g_64 = dyn($src0, block_x + 6, block_y + 4)
g_74 = dyn($src0, block_x + 7, block_y + 4)

g_05 = dyn($src0, block_x + 0, block_y + 5)
g_15 = dyn($src0, block_x + 1, block_y + 5)
g_25 = dyn($src0, block_x + 2, block_y + 5)
g_35 = dyn($src0, block_x + 3, block_y + 5)
g_45 = dyn($src0, block_x + 4, block_y + 5)
g_55 = dyn($src0, block_x + 5, block_y + 5)
g_65 = dyn($src0, block_x + 6, block_y + 5)
g_75 = dyn($src0, block_x + 7, block_y + 5)

g_06 = dyn($src0, block_x + 0, block_y + 6)
g_16 = dyn($src0, block_x + 1, block_y + 6)
g_26 = dyn($src0, block_x + 2, block_y + 6)
g_36 = dyn($src0, block_x + 3, block_y + 6)
g_46 = dyn($src0, block_x + 4, block_y + 6)
g_56 = dyn($src0, block_x + 5, block_y + 6)
g_66 = dyn($src0, block_x + 6, block_y + 6)
g_76 = dyn($src0, block_x + 7, block_y + 6)

g_07 = dyn($src0, block_x + 0, block_y + 7)
g_17 = dyn($src0, block_x + 1, block_y + 7)
g_27 = dyn($src0, block_x + 2, block_y + 7)
g_37 = dyn($src0, block_x + 3, block_y + 7)
g_47 = dyn($src0, block_x + 4, block_y + 7)
g_57 = dyn($src0, block_x + 5, block_y + 7)
g_67 = dyn($src0, block_x + 6, block_y + 7)
g_77 = dyn($src0, block_x + 7, block_y + 7)


# ==============================================================================
# 3. PRE-NORMALIZATION: Apply normalization factors C(u) and C(v) to each
#    coefficient before the summation.
# ==============================================================================

# Define normalization constants.
inv_sqrt_N = 1 / sqrt(N)
sqrt_2_div_N = 0.5

# C(k) is inv_sqrt_N for k=0, and sqrt_2_div_N for k>0.
norm_u0 = inv_sqrt_N
norm_u1 = sqrt_2_div_N
norm_u2 = sqrt_2_div_N
norm_u3 = sqrt_2_div_N
norm_u4 = sqrt_2_div_N
norm_u5 = sqrt_2_div_N
norm_u6 = sqrt_2_div_N
norm_u7 = sqrt_2_div_N

norm_v0 = inv_sqrt_N
norm_v1 = sqrt_2_div_N
norm_v2 = sqrt_2_div_N
norm_v3 = sqrt_2_div_N
norm_v4 = sqrt_2_div_N
norm_v5 = sqrt_2_div_N
norm_v6 = sqrt_2_div_N
norm_v7 = sqrt_2_div_N

# Create normalized coefficient variables `ng_uv`.
ng_00 = g_00 * norm_u0 * norm_v0
ng_10 = g_10 * norm_u1 * norm_v0
ng_20 = g_20 * norm_u2 * norm_v0
ng_30 = g_30 * norm_u3 * norm_v0
ng_40 = g_40 * norm_u4 * norm_v0
ng_50 = g_50 * norm_u5 * norm_v0
ng_60 = g_60 * norm_u6 * norm_v0
ng_70 = g_70 * norm_u7 * norm_v0
ng_01 = g_01 * norm_u0 * norm_v1
ng_11 = g_11 * norm_u1 * norm_v1
ng_21 = g_21 * norm_u2 * norm_v1
ng_31 = g_31 * norm_u3 * norm_v1
ng_41 = g_41 * norm_u4 * norm_v1
ng_51 = g_51 * norm_u5 * norm_v1
ng_61 = g_61 * norm_u6 * norm_v1
ng_71 = g_71 * norm_u7 * norm_v1
ng_02 = g_02 * norm_u0 * norm_v2
ng_12 = g_12 * norm_u1 * norm_v2
ng_22 = g_22 * norm_u2 * norm_v2
ng_32 = g_32 * norm_u3 * norm_v2
ng_42 = g_42 * norm_u4 * norm_v2
ng_52 = g_52 * norm_u5 * norm_v2
ng_62 = g_62 * norm_u6 * norm_v2
ng_72 = g_72 * norm_u7 * norm_v2
ng_03 = g_03 * norm_u0 * norm_v3
ng_13 = g_13 * norm_u1 * norm_v3
ng_23 = g_23 * norm_u2 * norm_v3
ng_33 = g_33 * norm_u3 * norm_v3
ng_43 = g_43 * norm_u4 * norm_v3
ng_53 = g_53 * norm_u5 * norm_v3
ng_63 = g_63 * norm_u6 * norm_v3
ng_73 = g_73 * norm_u7 * norm_v3
ng_04 = g_04 * norm_u0 * norm_v4
ng_14 = g_14 * norm_u1 * norm_v4
ng_24 = g_24 * norm_u2 * norm_v4
ng_34 = g_34 * norm_u3 * norm_v4
ng_44 = g_44 * norm_u4 * norm_v4
ng_54 = g_54 * norm_u5 * norm_v4
ng_64 = g_64 * norm_u6 * norm_v4
ng_74 = g_74 * norm_u7 * norm_v4
ng_05 = g_05 * norm_u0 * norm_v5
ng_15 = g_15 * norm_u1 * norm_v5
ng_25 = g_25 * norm_u2 * norm_v5
ng_35 = g_35 * norm_u3 * norm_v5
ng_45 = g_45 * norm_u4 * norm_v5
ng_55 = g_55 * norm_u5 * norm_v5
ng_65 = g_65 * norm_u6 * norm_v5
ng_75 = g_75 * norm_u7 * norm_v5
ng_06 = g_06 * norm_u0 * norm_v6
ng_16 = g_16 * norm_u1 * norm_v6
ng_26 = g_26 * norm_u2 * norm_v6
ng_36 = g_36 * norm_u3 * norm_v6
ng_46 = g_46 * norm_u4 * norm_v6
ng_56 = g_56 * norm_u5 * norm_v6
ng_66 = g_66 * norm_u6 * norm_v6
ng_76 = g_76 * norm_u7 * norm_v6
ng_07 = g_07 * norm_u0 * norm_v7
ng_17 = g_17 * norm_u1 * norm_v7
ng_27 = g_27 * norm_u2 * norm_v7
ng_37 = g_37 * norm_u3 * norm_v7
ng_47 = g_47 * norm_u4 * norm_v7
ng_57 = g_57 * norm_u5 * norm_v7
ng_67 = g_67 * norm_u6 * norm_v7
ng_77 = g_77 * norm_u7 * norm_v7


# ==============================================================================
# 4. COLUMN TRANSFORMS: Sum over frequency v for each column u.
#    This produces 8 intermediate values.
# ==============================================================================

# Pre-calculate cosine terms for the column transform (depends on y).
# cos_yv = cos((2 * y + 1) * v * pi / 16)
cos_y0 = cos((2 * y + 1) * 0 * $pi / 16) # This is always 1
cos_y1 = cos((2 * y + 1) * 1 * $pi / 16)
cos_y2 = cos((2 * y + 1) * 2 * $pi / 16)
cos_y3 = cos((2 * y + 1) * 3 * $pi / 16)
cos_y4 = cos((2 * y + 1) * 4 * $pi / 16)
cos_y5 = cos((2 * y + 1) * 5 * $pi / 16)
cos_y6 = cos((2 * y + 1) * 6 * $pi / 16)
cos_y7 = cos((2 * y + 1) * 7 * $pi / 16)

# Calculate the 8 intermediate sums.
col_sum_0 = ng_00 * cos_y0 + ng_01 * cos_y1 + ng_02 * cos_y2 + ng_03 * cos_y3 + ng_04 * cos_y4 + ng_05 * cos_y5 + ng_06 * cos_y6 + ng_07 * cos_y7
col_sum_1 = ng_10 * cos_y0 + ng_11 * cos_y1 + ng_12 * cos_y2 + ng_13 * cos_y3 + ng_14 * cos_y4 + ng_15 * cos_y5 + ng_16 * cos_y6 + ng_17 * cos_y7
col_sum_2 = ng_20 * cos_y0 + ng_21 * cos_y1 + ng_22 * cos_y2 + ng_23 * cos_y3 + ng_24 * cos_y4 + ng_25 * cos_y5 + ng_26 * cos_y6 + ng_27 * cos_y7
col_sum_3 = ng_30 * cos_y0 + ng_31 * cos_y1 + ng_32 * cos_y2 + ng_33 * cos_y3 + ng_34 * cos_y4 + ng_35 * cos_y5 + ng_36 * cos_y6 + ng_37 * cos_y7
col_sum_4 = ng_40 * cos_y0 + ng_41 * cos_y1 + ng_42 * cos_y2 + ng_43 * cos_y3 + ng_44 * cos_y4 + ng_45 * cos_y5 + ng_46 * cos_y6 + ng_47 * cos_y7
col_sum_5 = ng_50 * cos_y0 + ng_51 * cos_y1 + ng_52 * cos_y2 + ng_53 * cos_y3 + ng_54 * cos_y4 + ng_55 * cos_y5 + ng_56 * cos_y6 + ng_57 * cos_y7
col_sum_6 = ng_60 * cos_y0 + ng_61 * cos_y1 + ng_62 * cos_y2 + ng_63 * cos_y3 + ng_64 * cos_y4 + ng_65 * cos_y5 + ng_66 * cos_y6 + ng_67 * cos_y7
col_sum_7 = ng_70 * cos_y0 + ng_71 * cos_y1 + ng_72 * cos_y2 + ng_73 * cos_y3 + ng_74 * cos_y4 + ng_75 * cos_y5 + ng_76 * cos_y6 + ng_77 * cos_y7


# ==============================================================================
# 5. ROW TRANSFORM: Sum the intermediate results over frequency u to get the
#    final pixel value.
# ==============================================================================

# Pre-calculate cosine terms for the row transform (depends on x).
# cos_xu = cos((2 * x + 1) * u * pi / 16)
cos_x0 = cos((2 * x + 1) * 0 * $pi / 16) # This is always 1
cos_x1 = cos((2 * x + 1) * 1 * $pi / 16)
cos_x2 = cos((2 * x + 1) * 2 * $pi / 16)
cos_x3 = cos((2 * x + 1) * 3 * $pi / 16)
cos_x4 = cos((2 * x + 1) * 4 * $pi / 16)
cos_x5 = cos((2 * x + 1) * 5 * $pi / 16)
cos_x6 = cos((2 * x + 1) * 6 * $pi / 16)
cos_x7 = cos((2 * x + 1) * 7 * $pi / 16)

# The final summation gives the reconstructed pixel value.
RESULT = col_sum_0 * cos_x0 + col_sum_1 * cos_x1 + col_sum_2 * cos_x2 + col_sum_3 * cos_x3 + col_sum_4 * cos_x4 + col_sum_5 * cos_x5 + col_sum_6 * cos_x6 + col_sum_7 * cos_x7
