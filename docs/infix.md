### Infix Representation Specification

This document describes the C-style output generated by the `postfix2infix.py` utility. The script converts a VapourSynth RPN expression into a C-style code snippet that is functionally equivalent.

---

### **1. General Conversion Rules**

-   **Data Types:** All calculations are performed using single-precision floats. Numeric literals from the RPN string are converted to C float literals by appending `.0f` to integers and `f` to floating-point numbers (e.g., `128` becomes `128.0f`, `3.14` becomes `3.14f`).
-   **Parentheses:** The conversion wraps most operations in parentheses `()` to ensure that the original order of operations from the RPN input is correctly preserved in the infix output.
-   **Core Identifiers:** Standard RPN identifiers are passed through directly as C variables:
    -   Clip identifiers: `x`, `y`, `z`, `a`...`w`, `src0`, `src1`...
    -   Coordinate/Frame properties: `X`, `Y`, `N`, `width`, `height`
    -   Constants: `pi`

---

### **2. Operator and Function Mapping**

The following table shows how RPN operators are mapped to their C-style infix equivalents. `{0}`, `{1}`, and `{2}` represent the operands popped from the stack.

| RPN Operator | Arity | C-Style Output | Notes |
| :--- | :--- | :--- | :--- |
| `+`, `-`, `*`, `/` | 2 | `({0} + {1})`, `({0} - {1})`, etc. | Basic arithmetic. |
| `%` | 2 | `fmodf({0}, {1})` | C's `fmodf` for floating-point modulo. |
| `pow`, `**` | 2 | `powf({0}, {1})` | Power function. |
| `sqrt` | 1 | `sqrtf({0})` | Square root. |
| `exp`, `log`, etc. | 1 | `expf({0})`, `logf({0})`, etc. | Standard math functions (suffixed with `f`). |
| `abs` | 1 | `fabsf({0})` | Absolute value for floats. |
| `min`, `max` | 2 | `fminf({0}, {1})`, `fmaxf({0}, {1})` | Min/max for floats. |
| `>` , `<`, `>=`, `<=`, `=` | 2 | `({0} > {1})`, `({0} == {1})`, etc. | Comparisons. Note `=` becomes `==`. |
| `and` | 2 | `(({0} > 0.0f) && ({1} > 0.0f))` | Logical AND. Truth is `> 0.0f`. |
| `or` | 2 | `(({0} > 0.0f) || ({1} > 0.0f))` | Logical OR. |
| `xor` | 2 | `((!!({0} > 0.0f)) ^ (!!({1} > 0.0f)))` | Logical XOR. |
| `not` | 1 | `(!({0} > 0.0f))` | Logical NOT. |
| `?` | 3 | `(({0} != 0.0f) ? {1} : {2})` | Ternary operator. `{0}` is the condition. |
| `clip`, `clamp` | 3 | `fminf(fmaxf({0}, {1}), {2})` | Clamps `{0}` between `{1}` and `{2}`. |
| `fma` | 3 | `fmaf({0}, {1}, {2})` | Fused multiply-add. |
| `bitand`, `bitor`, `bitxor` | 2 | `((int){0} & (int){1})`, etc. | Operands are cast to `int` for bitwise ops. |
| `bitnot` | 1 | `(~(int){0})` | Operand is cast to `int`. |

---

### **3. Data Access Syntax**

Pixel and property accessors are converted into a custom, method-like syntax.

| RPN Syntax | C-Style Output | Description |
| :--- | :--- | :--- |
| `x`, `srcN` | `x`, `srcN` | The current pixel value from the specified clip. |
| `x[relX,relY]` | `x.rel(relX, relY)` | Relative pixel access. |
| `x[relX,relY]:c` | `x.rel(relX, relY, "c")` | Relative access with clamp mode. |
| `x[relX,relY]:m` | `x.rel(relX, relY, "m")` | Relative access with mirror mode. |
| `absX absY x[]` | `x.abs(absX, absY)` | Absolute pixel access. `absX` and `absY` are the results of prior expressions. |
| `x.PropName` | `x.prop("PropName")` | Frame property access. The property name becomes a string literal. |

---

### **4. Stack Manipulation**

-   `dup`, `dupN`, `swap`, `swapN`, `drop`, `dropN`: These operators are handled by the converter's internal stack logic. They do not produce direct C output but correctly arrange operands for other operators.
-   `sortN`: Sorts the top `N` items on the stack. This operator forces the output into **Statement Block Mode**. The conversion generates a block of C code that stores the `N` stack items into temporary variables and then sorts them using a series of compare-and-swap operations. The names of the sorted temporary variables are then pushed back onto the stack for subsequent operations, with the largest value on top.